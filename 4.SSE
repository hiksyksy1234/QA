Spring Framework에서 Server-Sent Events (SSE)를 처리하기 위한 클래스로 SSE는 서버에서 클라이언트로 실시간으로 데이터를 전송하는 방법 중 하나 입니다.

# header.html
var eventSource = new EventSource("../sse"); //http://localhost:9900/myhome9/sse
let count=0;

eventSource.addEventListener('notification',  function(event) {
	 if(event.data != ''){
	    count++;
		  console.log(event.data);
    
});



# SseController.java
@RestController
public class SseController {
	@Autowired
    private SseService sseService;
   
    @GetMapping("/sse")
    public SseEmitter streamSse(Principal principal) {
        return sseService.createEmitter(principal.getName());
    }
}


# SseService.java
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

public interface SseService {
	
    public SseEmitter createEmitter(String userId) ;

    //특정 사용자에게 알림을 보내는 메서드입니다.
    public void sendNotification(String userId, String message) ; 

	public int update(String name) ;
	
}

#SseServiceImple.java
private static final Logger logger   = LoggerFactory.getLogger(SseService.class);	
	
    private final Map<String, SseEmitter> emitters = new ConcurrentHashMap<>();  
    /*
      SseEmitter를 사용하여 Server-Sent Events (SSE)를 생성하는 메서드입니다. 
      SSE는 서버에서 클라이언트로 데이터를 스트리밍하는 데 사용됩니다. 
     */
    public SseEmitter createEmitter(String userId) {
    	//userId에 해당하는 SSEEmitter를 생성합니다.
        //SseEmitter emitter = new SseEmitter();
    	SseEmitter emitter = new SseEmitter(Long.MAX_VALUE);
        
        //생성된 emitter를 this.emitters 맵에 저장합니다. 맵은 userId를 키로 사용하고, 생성된 emitter를 값으로 갖습니다.
        this.emitters.put(userId, emitter);
        
        // emitter의 완료 이벤트와 타임아웃 이벤트가 발생할 때마다 해당 userId에 해당하는 emitter를 맵에서 제거하는 작업을 수행합니다.
        emitter.onCompletion(() -> {this.emitters.remove(userId); logger.info("onCompletion()");});
        emitter.onTimeout(() -> {this.emitters.remove(userId);logger.info("onTimeout()");});
       
        
        
        //503에러를 방지하기 위한 더미 이벤트 전송
        try {
        	//알림은 emitter.send() 메서드를 사용하여 전송됩니다.
        	//SseEmitter.event().name("notification").data(message)를 사용하여 이름이 "notification"이고 
        	//데이터가 message인 이벤트를 생성하고 전송합니다.
        
        		emitter.send(SseEmitter.event().name("notification").data(""));
        
        } catch (IOException e) {
        	//전송 중 예외가 발생하면(IOException), 해당 emitter를 에러 상태로 완료합니다.
            emitter.completeWithError(e);
        }
        return emitter;
    }

    //특정 사용자에게 알림을 보내는 메서드입니다.
    public void sendNotification(String userId, String message) {
    	//userId를 사용하여 this.emitters 맵에서 해당 사용자에 대한 SseEmitter를 가져옵니다.
        SseEmitter emitter = this.emitters.get(userId);
        
       
        //가져온 emitter가 null이 아닌 경우, 즉 해당 사용자에게 SseEmitter가 존재하는 경우에만 알림을 전송합니다.
        if (emitter != null) {
            try {
            	//알림은 emitter.send() 메서드를 사용하여 전송됩니다.
            	//SseEmitter.event().name("notification").data(message)를 사용하여 이름이 "notification"이고 
            	//데이터가 message인 이벤트를 생성하고 전송합니다.
            	   emitter.send(SseEmitter.event().name("notification").data(msg));
            	
            } catch (IOException e) {
            	//전송 중 예외가 발생하면(IOException), 해당 emitter를 에러 상태로 완료합니다.
                emitter.completeWithError(e);
            }
        }
    }


# MemberController.java
@Controller
@RequestMapping(value="/member")
public class MemberController {
      @Autowired
      private SseService sseService;

       //회원가입처리
		@RequestMapping(value = "/joinProcess",   method = RequestMethod.POST)
		public String joinProcess(  Member member, 
									RedirectAttributes rattr, 
									Model model, 
									HttpServletRequest request)   {	

              int result = memberservice.insert(member);
              if (result == 1) {
				         sseService.sendNotification("admin", member.getId() + "님 회원가입");
              }
  ...
 }
}
